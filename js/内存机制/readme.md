# JS内存机制

- JS 执行机制
   - 调用栈
   - 执行上下文
       - 变量环境：体现 var 与函数声明的提升与初始化差异。
       - 词法环境：存放 let/const 、块级作用域、函数声明； 
       - outer 词法作用域链，带 outer 指针形成作用域链（标识符查找从当前环境沿 outer 向外到全局）。
           - 闭包 closure 
       - this

- JS 内存机制
   - 栈内存 简单数据类型（拷贝式赋值）
        原始类型： number 、 string 、 boolean 、 null 、 undefined 、 symbol 、 bigint
   - 堆内存 复杂数据类型（引用式赋值）
        引用类型： object 、 array 、 function 等

- JS 是什么语言？（弱类型的动态语言）
   - 静态语言
       - 在**编译时**确定变量类型，如 C++、Java、Go 等
   - 动态语言：
       - 在**运行时**确定变量类型，如 JavaScript、Python、Ruby 等

   - 强类型
       - 变量类型确定后，不能改变
   - 弱类型 
       - 运行时可以转换为各种类型

- JS 要直接操作内存吗？
    - 不需要，JS 有垃圾回收机制，自动管理内存。
    而 c，c++ malloc free 操作内存


## 内存空间
- 代码空间
    代码从硬盘读取到内存中
- 栈内存
    调用栈（JS执行的主角）所有代码的执行都由调用栈来维护
        快，好管理，大小固定
    调用栈的栈顶指针切换要快，小，连续，切换很频繁
- 堆内存
    辅助
    大对象的空间，分配更耗时
    对象是动态的，所以不连续的

    JS V8引擎需要用栈来维护程序执行期间上下文的状态。
    如果栈空间太大了，不连续的（如果复杂数据类型也放在栈内存中），那么会影响上下文切换的效率，进而影响整个程序的执行效率
    执行上下文的切换，其实是执行栈栈顶指针的偏移，空间越小偏移越快

    栈空间就用于存放原始数据类型（空间占据不大，且连续）
    堆空间很大，能存放很多大数据，但是缺点就是分配内存和回收内存都会占据一定的时间

   - 简单数据类型就直接使用
   - 复杂数据类型是堆内存的引用地址，二传手
        回收的时候，栈回收就是瞬间完成（指针偏移），堆内存中的对象没有变量引用，慢慢回收。 

## 内存机制理解闭包
- 执行流程
   - 先编译 foo 函数，创建一个空执行上下文（全局执行上下文）
   - 执行 foo 之前，编译过程，setName，getName 快速的词法扫描（var）
        闭包内部函数，myName test1 由内部函数引用的自由变量，JS就会判断有闭包，堆空间中创建一个closure(foo)
   - getName，setName 执行可以访问到closure(foo) 

    闭包核心 第一步：需要扫描内部函数，堆内存中
    第二步：把内部函数引用的外部变量保存到堆中



## 回顾总结：
- 解析/编译期：把源码解析成 AST，生成可执行表示（字节码/IR），不会执行语句，也不会创建字面量对象实例。
- 创建阶段（执行上下文建立/提升）：进入脚本或调用函数时，先为当前上下文建立环境记录、作用域链、`this` 绑定，并处理声明的提升。
- 执行阶段：按顺序逐行执行语句，进行实际的赋值、运算、函数调用与对象创建。
- 异步阶段（事件循环）：同步代码跑完后，按队列调度微任务与宏任务，每次运行都会在一个新的栈上开启“创建→执行→结束”的小循环。

**创建阶段（提升细节）**
- 变量绑定：
  - `var`：创建绑定并初始化为 `undefined`
  - `let/const`：创建绑定但进入 TDZ（暂时性死区），在赋值前不可访问。
- 函数：
  - 函数声明：整体创建并绑定，可在声明前调用。
  - 函数表达式：只是一个变量，遵循 `var/let/const` 的各自规则。
- `this`：
  - 模块顶层与严格模式函数：顶层 `this === undefined`；普通函数的 `this` 取决于调用方式。
- 作用域链：为当前 `LexicalEnvironment` 设置 `outer` 指向外层，完成标识符查找路径。

**执行阶段（实际运行）**
- 读取与赋值：根据作用域链从内到外查找变量，再执行赋值或运算。
- 对象与函数实例：在执行到相应语句时分配到堆，并把“引用”写入变量绑定。
- 调用栈：
  - 调用函数时压入新的上下文为栈顶；返回后弹栈切回上一个上下文。
  - 栈顶切换开销很小，基本是移动栈指针和少量元数据更新。
- 回收与闭包：
  - 栈帧弹出后，未被引用的临时对象会进入 GC 过程。
  - 若有闭包捕获外层变量，其环境会留在堆上，直到不可达才回收。

**事件循环（异步执行）**
- 同步代码先跑完；随后按顺序处理任务队列：
- 每次处理一个任务时，会再次经历“创建阶段→执行阶段→结束”的流程，但这是新的调用栈，不会与之前的同步栈混用。

**速记**
- 提升只创建绑定：`var -> undefined`，`let/const -> TDZ`，函数声明可用。
- 对象在执行时创建：变量里保存的是“引用”，引用赋值会共享同一对象。
- 调用栈只记录“谁在执行”：作用域链决定“变量去哪儿找”；异步任务在后续循环里用新的栈执行。
